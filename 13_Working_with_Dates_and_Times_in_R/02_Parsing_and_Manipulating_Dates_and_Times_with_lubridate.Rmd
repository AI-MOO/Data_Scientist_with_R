---
title: "Parsing and Manipulating Dates and Times with lubridate"
author: "Mohamad Osman"
date: '2022-06-28'
output: rmarkdown::github_document
---

# Section 02: **Parsing and Manipulating Dates and Times with lubridate**

### **`01-Selecting the right parsing function`**

`lubridate` provides a set of functions for parsing dates of a known order. For example, [**`ymd()`**](https://www.rdocumentation.org/packages/lubridate/versions/1.8.0/topics/ymd) will parse dates with year first, followed by month and then day. The parsing is flexible, for example, it will parse the `m` whether it is numeric (e.g. `9` or `09`), a full month name (e.g. `September`), or an abbreviated month name (e.g. `Sep`).

For each date the ISO 8601 format is displayed as a comment after it, to help you check your work

-   Choose the correct function to parse `x`.

-   Choose the correct function to parse `y`.

-   Choose the correct function to parse `z`.

```{r}
library(lubridate)

# Parse x 
x <- "2010 September 20th" # 2010-09-20
ymd(x)

# Parse y 
y <- "02.01.2010"  # 2010-01-02
dmy(y)

# Parse z 
z <- "Sep, 12th 2010 14:00"  # 2010-09-12T14:00
mdy_hm(z)
```

### **`` 02-Specifying an order with `parse_date_time()` ``**

One advantage of `parse_date_time()` is that you can use more format characters. For example, you can specify weekday names with `A`, `I` for 12 hour time, am/pm indicators with `p` and many others. You can see a whole list on the help page [**`?parse_date_time`**](https://www.rdocumentation.org/packages/lubridate/versions/1.8.0/topics/parse_date_time).

Another big advantage is that you can specify a vector of orders, and that allows parsing of dates where multiple formats might be used.

-   `x` is a trickier datetime. Use the clues in the instructions to parse `x`.

-   `two_orders` has two different orders, parse both by specifying the order to be `c("mdy", "dmy")`.

-   Parse `short_dates` with `orders = c("dOmY", "OmY", "Y")`. *What happens to the dates that don't have months or days specified?*

```{r}
# Specify an order string to parse x
x <- "Monday June 1st 2010 at 4pm"
parse_date_time(x, orders = "amdYIp")

# Specify order to include both "mdy" and "dmy"
two_orders <- c("October 7, 2001", "October 13, 2002", "April 13, 2003","17 April 2005", "23 April 2017")
parse_date_time(two_orders, orders = c("mdy", "dmy"))

# Specify order to include "dOmY", "OmY" and "Y"
short_dates <- c("11 December 1282", "May 1372", "1253")
parse_date_time(short_dates, orders =  c("dOmY", "OmY", "Y"))

```

### **`03-Import daily weather data`**

-   Import the daily data, `"akl_weather_daily.csv"` with `read_csv()`.

-   Print `akl_daily_raw` to confirm the `date` column hasn't been interpreted as a date. *Can you see why?*

-   Using `mutate()` overwrite the column `date` with a parsed version of `date`. You need to specify the parsing function. Hint: the first date should be September 1.

-   Print `akl_daily` to verify the `date` column is now a `Date`.

-   Take a look at the data by plotting `date` on the x-axis and `max_temp` of the y-axis

```{r}
library(lubridate)
library(readr)
library(dplyr)
library(ggplot2)

# Import CSV with read_csv()
akl_weather_daily_path <- file.path("..", "00_Datasets", "Auckland_daily_weather.csv")
akl_daily_raw <- read.csv(akl_weather_daily_path)

# Print akl_daily_raw
akl_daily_raw

# Parse date 
akl_daily <- akl_daily_raw %>%
  mutate(date = ymd(date))

# Print akl_daily
akl_daily

# Plot to check work
ggplot(akl_daily, aes(x = date, y = max_temp)) +
  geom_line()
```

### **`04-Import hourly weather data`**

-   Import the hourly data, `"akl_weather_hourly_2016.csv"` with `read_csv()`, then print `akl_hourly_raw` to confirm the date is spread over `year`, `month` and `mday`.

-   Using `mutate()` create the column `date` with using `make_date()`.

-   We've pasted together the `date` and `time` columns. Create `datetime` by parsing the `datetime_string` column.

-   Take a look at the `date`, `time` and `datetime` columns to verify they match up.

-   Take a look at the data by plotting `datetime` on the x-axis and `temperature` of the y-axis.

```{r}
library(lubridate)
library(readr)
library(dplyr)
library(ggplot2)

# Import "akl_weather_hourly_2016.csv"
akl_weather_h_path <- file.path("..", "00_Datasets", "akl_weather_hourly_2016.csv")
akl_hourly_raw <- read_csv(akl_weather_h_path)

# Print akl_hourly_raw
akl_hourly_raw

# Use make_date() to combine year, month and mday 
akl_hourly  <- akl_hourly_raw  %>% 
  mutate(date = make_date(year = year, month = month, day = mday))

# Parse datetime_string 
akl_hourly <- akl_hourly  %>% 
  mutate(
    datetime_string = paste(date, time, sep = "T"),
    datetime = parse_date_time(datetime_string, orders = "ymdHMS")
  )

# Print date, time and datetime columns of akl_hourly
akl_hourly %>% select(date, time, datetime)

# Plot to check work
ggplot(akl_hourly, aes(x = datetime, y = temperature)) +
  geom_line()
```

\
